## Introduction
**Newton's Method** is used for rootfinding. I see it as somewhat similar to [[4.2 Fixed-point iteration]], but instead of using $y=x$ to continuously approach a solution, we use tangent lines to do so. We start with guess $f(x_k)$,  find it's derivative $f'(x_k)$, and then repeat with $x_{k+1}$ defined as $x_k - \frac{f(x_k)}{f'(x_k)}$ .

>[!abstract] Algorithm: Newton's method
>Given a function $f$, its derivative, $f'$, and an initial value $x_1$, iteratively define
>$$x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)}, \ \ \ \ k=1, 2, ...$$

The first iteration may look something like this
![[Plot-4-3-tan1.png|500]]

And even by the second iteration you can see how quickly this converges
![[Plot-4-3-tan2.png|500]]
## Convergence
>[!info] Observation
>Asymptotically, each iteration of Newton's method roughly squares the error

>[!notes] Def: Quadratic Convergence
>Suppose a sequence $x_k$ approaches limit $x^*$. If the errors sequence $\epsilon_k = x_k - x^*$ satisfies
>$$\lim_{k\rightarrow \infty} \frac{|\epsilon_{k+1}|}{|\epsilon_k|^2} = L$$
>for a positive constant L, then the sequence has **quadratic convergence to the limit**

Recall from [[4.2 Fixed-point iteration#Linear Convergence|4.2]] that linear convergence is identifiable by trending toward a straight line on a log-linear plot of the error. When the convergence is quadratic, no such straight line exists

The above definition does need some assumptions 
1. The residual function $f$ has to have enough continuous derivatives to make the Taylor series expansion valid. 
2. $f'(r) \neq 0$, meaning $r$ must be a simple root
3. We assumed that the sequence converged. This is not easy to guarantee, but will be addressed in [[4.6 Quasi-Newton methods]] 

## Implementation
**Newton's Method for a scalar rootfinding problem**
```julia
function newton(f,dfdx,x₁;maxiter=40,ftol=100*eps(),xtol=100*eps())
    x = [float(x₁)]
    y = f(x₁)
    Δx = Inf   # for initial pass below
    k = 1

    while (abs(Δx) > xtol) && (abs(y) > ftol)
        dydx = dfdx(x[k])
        Δx = -y/dydx            # Newton step
        push!(x,x[k]+Δx)        # append new estimate
        k += 1
        y = f(x[k])
        if k==maxiter
            @warn "Maximum number of iterations reached."
            break   # exit loop
        end
    end
    return x
end
```
**Code explanation**
```julia
function newton(f,dfdx,x₁;maxiter=40,ftol=100*eps(),xtol=100*eps())
```
The function newton takes in the function $f$, it's derivative dfdx ($f'(x)$), and an initial guess $x_1$. The arguments past `;` are *optional keyword arguments* (see [here](https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments))  

```julia 
...
    x = [float(x₁)]
    y = f(x₁)
    Δx = Inf   # for initial pass below
```
This instantiates a few variables, notably $\Delta x$ , which we will use to determine how close our approximation is getting to the actual result. We set it to $\infty$ to ensure that the first iteration occurs

```julia showLineNumbers{8}
		dydx = dfdx(x[k])
		Δx = -y/dydx            # Newton step
		push!(x,x[k]+Δx)        # append new estimate
		k += 1
		y = f(x[k])
```

While we are above some tolerance we continuously reevaluate our guess, our $\Delta x$, and update our increment variable $k$

```julia showLineNumbers{13}
        if k==maxiter
            @warn "Maximum number of iterations reached."
            break   # exit loop
        end
```
We need to protect against the possibility that we are checking a nonconvergent iteration. If the loop runs too many times, we just break out of the loop and display a warning
## Examples
Exercise 4.3.7 from the textbook
>[!example] 
>Plot $f(x) = x^{-2} - sin(x)$ on the interval $x \in [0.5, 10]$
>Make a table for the different roots found using these different initial guesses: $x_1 = [1, 2, ..., 7]$ 

```julia 
f = x-> x^(-2) - sin(x)
# derivative of f
f′ = x-> -1 * cos(x) - (2/(3 * x^3))

xs = [1,2,3,4,5,6,7];

plt = plot(f, 0.5, 10, xticks=1:8, label="f(x)", linewidth=3, title="")
plot!(f′, 0.5, 10, label="f'(x)")
```
![[Plot-ex-4-3-7.png|500]]

```julia showLineNumbers{9}
# using the newton() function defined previously
estimates = []
for i in xs
	push!(estimates, newton(f, f′, xs[i])[end]) #only need final estimate
end

scatter!(xs, f.(xs), label="initial guesses", markersize=3)
scatter!(estimates, f.(estimates), label="Final estimates")
```
![[Plot-ex-4-3-7_2.png|500]]
```julia showLineNumbers{17}
println("Initial Guess xᵢ\t || Final Estimate")
println("----------------------------------------------")

for i = 1:length(estimates)
	println("\t$(xs[i])\t\t\t$(round(estimates[i], digits=5))")
end
```
![[Final_est-ex-4-3-7.png|300]]