## Introduction

This chapter extends from linear algebra to deal with nonlinear algebraic problems. Much of numerical analysis is about the finding the zeros to functions, but what happens when you have a nasty function that you can't just set equal to zero and solve?

This now becomes a **rootfinding problem**
>[!notes] Def: rootfinding problem
>For a continuous scalar function $f$ of a scalar variable, find a real number $r$ (the root), such that $f(r) = 0$

Since we are dealing with nasty functions, we are instead seeking a sequence of approximations that converge to the root

The textbook uses Bessel functions as an example
```julia
using Plots, Bessels, NLsolve

J3(x) = besselj(3, x)
plot(J3, 0, 20, label=:none, xaxis=(L"x"), yaxis=(L"J_3(x)"))

w = []
for guess = [6., 10., 13., 16., 19.]
    s = nlsolve(x->besselj(3, x[1]), [guess], ftol=1e-14)
    append!(w, s.zero)
end

scatter!(w, J3.(w), title="Bessel function with roots", label="Roots")
```

![[TextbookBesselPlot.png|500]]

**Code Explanation**
```julia
J3(x) = besselj(3, x)
```
This creates a function J3, that takes in one parameter 'x'. It returns the result of the Bessel function $J_v(x)$, where v = 3, and x = x.

```julia
for guess = [...]
```
This will iterate through each value provided in the brackets

```julia
s = nlsolve(x->besselj(3, x[1]), [guess], ftol=1e-14)
append!(w, s.zero)
```
This uses nlsolve() from the NLsolve.jl package ([docs here](https://github.com/JuliaNLSolvers/NLsolve.jl)).  The first input to it should be a function, which is done here using `x-> ...` , which is the convention for a [Julia anonymous function](https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions). If you're unfamiliar, this is for moments where you want to use a function just once, and so you don't really need to name it. It checks the result of the anonymous function at some guess, and continues approximating until it is within some tolerance of the function. `append!(w, s.zero)` adds the zero (the root) of the approximation to a vector

Note: this only shows the first 5 roots, but this can be taken further as shown below
![[Bessel.gif|500x400]]


## Conditioning, error, and residual
In the rootfinding problem, the data is a continuous function $f$ and the result is a root. The question now is, how does the result change in response to perturbations in $f$? 

For this, we will be using the **absolute** condition number rather than the relative one.
>[!notes] Theorem: **absolute** condition number of rootfinding
>If $f$ is differentiable at root $r$, the absolute condition number of $r$ with respect to constant changes in $f$ is $$\kappa_{r} = |f'(r)|^{-1}$$
>We say $\kappa_{r}= \infty$ if $f'(r) = 0$


When $|f'|$ is small at the root, we may not be able to get a small error in our computer estimate of the root. To combat this, we can measure the rootfinding residual
>[!notes] Def: rootfinding residual
>If $\tilde{r}$ approximates a root $r$ of the function $f$, then the residual at $\tilde{r}$ is $f(\tilde{r})$ 
>

>[!info] Observation
>The backward error in a root estimate is equal to the residual

It is usually unrealistic to expect a small error in the root approximation if the condition number is large, but we can gauge the backward error from the residual

## Multiple roots
The multiplicity of a root refers to the number of times the function $f(x)$ touches or crosses the x-axis at that point.

>[!notes] Def: the multiplicity of a root
If $f(r) = f'(r) = ... = f^{(m-1)}(r) = 0$ , but $f^{(m)}(r) \neq 0$, then we say that $f$ has a root of multiplicity $m$ at $r$. In particular, if $f(r) = 0$ and $f'(r) \neq 0$, then $m = 1$ and we call $r$ a simple root

## Examples
I have based this example on exercise 4.1.7. I am using a different equation from those listed in the exercise in case this question appears on our homework. 

>[!example] 
>For $f(x) = x^{4}- 4x^{3}+ 6x^{2}- 4x + 1$, find the multiplicity at the root $r = 1$. If it is a simple root, find its absolute condition number

![[4.1.7.jpg]]


This one is inspired by exercise 4.1.1
>[!example] 
> Use nlsolve to find each root of $2x^2 = 20x - csc(x)$ over $[0, 15]$

First convert the equation into the form $f(x) = 0$

$$f(x) = 2x^2 - 20x + csc(x) = 0$$

Now for some code! First let's model this function

```julia 
function f(x)
	return (2 * x[1]^2 - 20 * x[1] + csc(x[1]))
end
```
*"What's the purpose of using x[1]?"*

The first argument to `nlsolve` is the function to be solved. `nlsolve` expects that this function takes in a vector. From my understanding, this is to handle multi-variable functions. So something like $f(x, y)$ would just be `function f(x) ...`, where `x[1]` is the 'x', and `x[2]` is the 'y'. So for us, even though it's a single variable function, we have to use the convention of `x[1]` to make nlsolve happy. 

Now let's plot our function over the provided range to formulate our guesses
```julia
plot(f, 0, 15, xticks=0:15)
```
Plots.jl is pretty good at autoformatting the plots, but I've added the xticks attribute to help me make some better guesses.
![[Plot-411.png|500x400]]

```julia
roots = []
for guess = [0.5, 3., 6.5, 9.2, 10., 12.5]  #best I could get looking at the graph
	sol = nlsolve(f, [guess], ftol = 1e-14)
	append!(roots, sol.zero)
end

@show roots
```

`roots = [0.227167, 3.11829, 6.30465, 9.34321, 10.10813, 12.5508]`

```julia
scatter!(roots, f.(roots))
```
![[Plot-411-scatter.png|500x400]]