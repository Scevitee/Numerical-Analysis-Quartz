## Introduction
Another method we can use for rootfinding is known as the **fixed point problem**. In this, we are seeking to find a value that is unchanged when used as an input to a function, i.e., the input of the function matches the output for this specific value
>[!notes] Def: Fixed-point problem
>GIven a function $g$, the fixed-point problem is to find a value $p$, called a **fixed point**, such that $g(p) = p$

*How do we use this for rootfinding?*
Recall from [[4.1 The rootfinding problem|4.1]] that the rootfinding problem implies $f(r) = 0$. If we modify the fixed-point problem a bit we can get:
$$g(r) = r - f(r)$$
which simple reduces to 

$$g(r) = r$$

To actually find a fixed point of any given $g(x)$, we can use **fixed point iteration**
>[!abstract] Algorithm: fixed-point iteration
>Given a function $g$ and an intial value $x_1$, define
>$$x_{k+1} = g(x_k), \ \ \ \ \ \ k = 1, 2, ...$$

The procedure for this algorithm is as follows:
1. Start with an initial guess $x_1$
2. Apply $g$ to $x_1$, calculate $x_2 = g(x_1)$ This gives the next approximation of the fixed point
3. Iterate: Continue the process, using the output of the previous step as the input for the next
4. Repeat until convergence / until the difference between the approximations is below a predetermined tolerance level

The textbook provides a fairly verbose demo that illustrates the algorithm. It's a lot to copy so I'll just leave this [link](https://fncbook.github.io/fnc/nonlineqn/demos/fp-spiral.html)

## Series Analysis
In the textbook demo, it shows that for one choice of $x_1$, the sequence converged to a fixed point, whereas for a different choice of $x_1$, it diverged. 
So, how can we tell if a fixed-point iteration will converge?

>[!info] Observation
>Fixed-point iteration for a differentiable $g(x)$ converges to a fixed point $p$ if the intial error is sufficiently small and $|g'(p)| < 1$. The iteration diverges for all initial values if $|g'(p)| > 1$

Below is an animation I've made illustrating how the initial guess can influence an iteration
![[anim_fps_10.gif]]

## Linear Convergence
It is valuable to not only know whether an iteration converges, but also the rate at which it converges. 
>[!notes] Def: Linear Convergence
>Suppose a sequence $x_k$ approaches limit $x^*$. If the error sequence $\epsilon_k = x_k - x^*$ satisfies
>$$\lim_{k\rightarrow\infty} \frac{|\epsilon_{k+1}|}{|\epsilon_k|} = \sigma < 1$$ 
>then the sequence displays **linear convergence**. The number $\sigma$ is called the **convergence rate**

Note: If a fixed-point $p$ is the desired limit of an iteration $x_1, x_2, ...$ , you can express this as an **error sequence** $\epsilon_1, \epsilon_2, ...$, where $\epsilon_k = x_k - p$

>[!info] Observation: Linear convergence in practice
>Linear convergence is marked by an approximate reduction of the error at each iteration by a constant factor, the convergence rate $\sigma$. When graphed on a log-linear scale, the errors lie on a straight line whose slope is the log of the convergence rate. Both manifest most strongly at the latest iterations

Below is a function encompassing [demo 4.2.3](https://fncbook.github.io/fnc/nonlineqn/demos/fp-converge.html) from the textbook which demonstrates this convergence
```julia
function eval_error(p::Polynomial, guess::Float64; iters=12)
	r = roots(p)
	rmin, rmax = extrema(r)
	g = x -> x - p(x)
	x = [guess]

	# evaluate g(x) at initial guess -> plug result back into g(x)
	# store results to plot afterwards
	for k = 1:iters
		push!(x, g(x[k]))
	end

	# plot the error
	err = @. abs(x - rmax)
	plt = plot(0:12, err, m=:o, yaxis=("error", :log10),
		xaxis="iteration number", title="Convergence of fixed point iteration")
	
	return plt
end

p = Polynomial([3.5, -4, 1])
eval_error(p, 2.1)
```
![[Plot-423.png|500]]

## Contraction Maps
The convergence condition $\sigma = |g'(p)|$ is actually a special case of a more general condition
>[!notes] Definition: Lipschitz condition
>A function $g$ is said to satisfy a **Lipschitz condition** with constant $L$ on the interval $S \subset \mathbb{R}$ if, for all $s, t \in S$,
>$$|g(s) - g(t)| \leq L|s - t|$$ 

The Lipschitz condition is a type of constraint that a function can satisfy. It is a measure of how well-behaved a function is in terms of how rapidly it can change. The condition uses a constant $L$ to bound the rate of change.

A function satisfying the Lipschitz condition is continuous in S. If $L < 1$, we call $g$ a **contraction mapping**. This is because the distances between points all decrease after an application of $g$

>[!notes] Theorem: Contraction Mapping
>Suppose $g$ satisfies the Lipschitz condition with $L < 1$ on an interval $S$. Then $S$ contains exactly one fixed point $p$ of $g$. If $x_1, x_2, ...$ are generated by the fixed-point iteration and they all like in $S$, then 
>$$|x_k - p| \leq L^{k-1}|x_1-p| \ \ \ \ \ \ for \ all \  \ k > 1$$

## Examples

Based off of exercises 4.2.1 and 4.2.2
>[!example]
>Show that $g(x) = 2\pi cos(x) - sin(x)$ has a fixed point at $p = 2\pi$
>Apply 15 fixed point iterations and plot the results

Verify fixed point:  $p=2\pi$ is a fixed point if and only if $g(2\pi) = 2\pi$
$$g(2\pi) = 2\pi cos(2\pi) - sin(2\pi)$$
$$g(2\pi) = 2\pi$$

```julia
function plot_fixed_iterations(g, guess; iterations=15)
	plt = plot(g, 5.8, 6.6, aspect_ratio=0.5, label="g(x)")
	plot!(x -> x, label="y=x")

	#initial points
	x = guess;
	y = g(x)
	
	for i = 1:iterations
		plot!([x, y], [y, y], arrow=true, label=:none)

		#apply fixed point algorithm
		x = y
		y = g(x)
		
		plot!([x, x], [x, y], arrow=true, label=:none)
	end
	#end result of the fixed point iterations
	scatter!([x], [y], label="($(round(x, digits=3)), $(round(y, digits=3)))")
	return plt
end

function g(x)
	return 2Ï€ * cos(x) - sin(x)
end

plt = plot_fixed_iterations(g, 6)

```
![[Plot-ex-421.png|500]]


The result here is fairly accurate, if you instead wanted to go until a threshold between the approximation and the actual result is crossed, you can instead do something like this

```julia
function plot_until_accurate(g, guess; threshold=5e-3)
	plt = plot(g, 5.8, 6.6, aspect_ratio=0.5, label="g(x)")
	plot!(x -> x, label="y=x")
	
	x = guess;
	y = g(x)
	iters = 1
	while abs(x - y) > threshold
		plot!([x, y], [y, y], arrow = true, label=:none)
		
		x = y
		y = g(x)
		
		plot!([x, x], [x, y], arrow = true, label=:none)
		iters += 1
	end
	
	scatter!([x], [y], markersize=6, label="($(round(x, digits=3)), $(round(y, digits=3)))")
	
	println("Numbers of iterations to complete: $iters")
	return plt
end

plt = plot_until_accurate(g, 6)
```
![[Plot_ex_421-2.png|500]]